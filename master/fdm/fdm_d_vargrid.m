% Thu Mar  1 04:02:43 MSK 2012
% Karl KÃ¤stner, Berlin
%
% setup of finite difference derivative matrices in 1D
% applies hogomenous Dirichlet boundary conditions
% transforms the three point Laplacian into a symmetric matrix
%
% Required postprocessing:
% - combination 1D matrices with the Kronecker product for higher dimensions
% - BCs of higher derivatives which are not homogenous Dirichlet
%
% last and first point and X are discarded as boundary points
% for five point kernels one additional point at the front and end are
% extrapolated
%
% example: 3 point Laplacian
% 
% todo: horner schemes
% todo: standard test case
function [L D] = fdm_d_vargrid(X,d,k)
    n = length(X)-2;

    % select kernel size
    switch (k)
        case {3} % three point kernels
            % coordinates of the 3-point kernels
            xl = X(1:end-2);
            xc = X(2:end-1);
            xr = X(3:end);
        % select order of the derivative
        switch (d)
        case {1}
            st = dbstack();
            error(st.name,'Not yet implemented');
        case {2}

            if (nargout > 1)
                % TODO - improve setup
                % symmetrie transform
                % D L x + V x = lambda x
                % Dy=x
                % sqrt(D) L sqrt(D) y + V y = lambda y
                % As = sqrt(D)*Au*inv(sqrt(D));
                % this xr-xl gets compensated later
                A =  [  2./(xc - xl), ...
                       -2*(xr - xl)./(xc.*xl - xl.*xr + xc.*xr - xc.^2), ...
                        2./(xr-xc) ];
                L = spdiags( [ [A(2:end,1); 0] A(:,2) [0; A(1:end-1,3)] ], -1:1, n, n);
                D = diag(sparse(sqrt(1./(xr - xl))));
                L = D*L*D;
            else
                % todo expand
                A = 2./[ (xr-xl).*(xc-xl), ...
                    -(xr-xc).*(xc-xl), ...
                     (xr-xc).*(xr-xl) ];
                L = spdiags( [ [A(2:end,1); 0] A(:,2) [0; A(1:end-1,3)]], -1:1, n, n);
            end
        otherwise
            st = dbstack();
            error(st.name,'Symmetric 3 point kernels support only derivatives up to order 2');
        end % switch
        case {5} % five point kernels
            % coordinates of the 5-point kernel
            xk = [ 2*X(1)-X(1); X(1:end-3)];
            xl =   X(1:end-2);
            xc =   X(2:end-1);
            xr =   X(3:end);
            xs = [ X(4:end); 2*X(end)-X(end-1)];

            %step widths
            hk = xl - xk;
            hl = xc - xl;
            %hc = xr - xl;
            hr = xr - xc;
            hs = xs - xr;
            hkl = hk + hl;
            hrs = hr + hs;

            % common denominator
            D5_ = [  -( xc.*xk.^3 + xk.^3.*xl + xk.^3.*xr + xk.^3.*xs - ...
            xk.^4 - xc.*xk.^2.*xl - xc.*xk.^2.*xr - xc.*xk.^2.*xs - ...
            xk.^2.*xl.*xr - xk.^2.*xl.*xs - xk.^2.*xr.*xs + ...
            xc.*xk.*xl.*xr + xc.*xk.*xl.*xs + xc.*xk.*xr.*xs - ...
            xc.*xl.*xr.*xs + xk.*xl.*xr.*xs), -(xl.^4 - xk.*xl.^3 - ...
            xl.^3.*xr - xl.^3.*xs - xc.*xl.^3 + xc.*xk.*xl.^2 + ...
            xc.*xl.^2.*xr + xc.*xl.^2.*xs + xk.*xl.^2.*xr + ...
            xk.*xl.^2.*xs + xl.^2.*xr.*xs - xc.*xk.*xl.*xr - ...
            xc.*xk.*xl.*xs + xc.*xk.*xr.*xs - xc.*xl.*xr.*xs - ...
            xk.*xl.*xr.*xs), xc.^4 - xc.^3.*xl - xc.^3.*xr - xc.^3.*xs - ...
            xc.^3.*xk + xc.^2.*xk.*xl + xc.^2.*xk.*xr + xc.^2.*xk.*xs + ...
            xc.^2.*xl.*xr + xc.^2.*xl.*xs + xc.^2.*xr.*xs - ...
            xc.*xk.*xl.*xr - xc.*xk.*xl.*xs - xc.*xk.*xr.*xs - ...
            xc.*xl.*xr.*xs + xk.*xl.*xr.*xs, xc.*xr.^3 + xk.*xr.^3 + ...
            xl.*xr.^3 + xr.^3.*xs - xr.^4 - xc.*xk.*xr.^2 - ...
            xc.*xl.*xr.^2 - xc.*xr.^2.*xs - xk.*xl.*xr.^2 - ...
            xk.*xr.^2.*xs - xl.*xr.^2.*xs + xc.*xk.*xl.*xr - ...
            xc.*xk.*xl.*xs + xc.*xk.*xr.*xs + xc.*xl.*xr.*xs + ...
            xk.*xl.*xr.*xs, -(xc.*xs.^3 + xk.*xs.^3 + xl.*xs.^3 + ...
            xr.*xs.^3 - xs.^4 - xc.*xk.*xs.^2 - xc.*xl.*xs.^2 - ...
            xc.*xr.*xs.^2 - xk.*xl.*xs.^2 - xk.*xr.*xs.^2 - ...
            xl.*xr.*xs.^2 - xc.*xk.*xl.*xr + xc.*xk.*xl.*xs + ...
            xc.*xk.*xr.*xs + xc.*xl.*xr.*xs + xk.*xl.*xr.*xs)];

	    D5 =[	(hkl.*hk.*(hkl + hr).*(hkl + hrs)), ...
			(hl.*hk.*(hl + hr).*(hl + hrs)), ...
			(hkl.*hl.*hr.*hrs), ...
			(hr.*hs.*(hkl + hr).*(hl + hr)), ...
			(hrs.*hs.*(hkl + hrs).*(hl + hrs)) ];

            % dummy symmetry transform matrix (no symmetry transform computet)
            D = speye(n);
            % select order of the derivative
            switch (d)
            case {1} % first derivative
                %st = dbstack();
                %error(st.name,'Not yet implemented');
		% TODO expand
		N_ = [ -(xc - xs).*(xc - xr).*(xc - xl), ...
                       (xc - xs).*(xc - xr).*(xc - xk), ...
                       4.*xc.^3 - 3.*xc.^2.*xl - 3.*xc.^2.*xr - 3.*xc.^2.*xs - 3.*xc.^2.*xk + 2.*xc.*xk.*xl + 2.*xc.*xk.*xr + 2.*xc.*xk.*xs + 2.*xc.*xl.*xr + 2.*xc.*xl.*xs + 2.*xc.*xr.*xs - xk.*xl.*xr - xk.*xl.*xs - xk.*xr.*xs - xl.*xr.*xs, ...
			-(xc - xs).*(xc - xl).*(xc - xk), ...
			-(xc - xr).*(xc - xl).*(xc - xk)
			];
		N = [	- ( xc.^2.*xl + xc.^2.*xr + xc.^2.*xs - xc.^3 - xc.*xl.*xr - xc.*xl.*xs - xc.*xr.*xs + xl.*xr.*xs ), ...
			- (xc.^3 - xc.^2.*xr - xc.^2.*xs - xc.^2.*xk + xc.*xk.*xr + xc.*xk.*xs + xc.*xr.*xs - xk.*xr.*xs ), ...
                       4.*xc.^3 - 3.*xc.^2.*xl - 3.*xc.^2.*xr - 3.*xc.^2.*xs - 3.*xc.^2.*xk + 2.*xc.*xk.*xl + 2.*xc.*xk.*xr + 2.*xc.*xk.*xs + 2.*xc.*xl.*xr + 2.*xc.*xl.*xs + 2.*xc.*xr.*xs - xk.*xl.*xr - xk.*xl.*xs - xk.*xr.*xs - xl.*xr.*xs, ...
			xc.^2.*xk + xc.^2.*xl + xc.^2.*xs - xc.^3 - xc.*xk.*xl - xc.*xk.*xs - xc.*xl.*xs + xk.*xl.*xs, ...
			- (xc.^2.*xk + xc.^2.*xl + xc.^2.*xr - xc.^3 - xc.*xk.*xl - xc.*xk.*xr - xc.*xl.*xr + xk.*xl.*xr ) ];
                A = N./D5;
            case {2} % second derivative (Laplacian)
            % Todo: expandet setup
%            A = [ ...
%                  -(2.*(hl.*hr + (hl - hr).*hrs))                  ./ (hkl.*hk.*(hkl + hr).*(hkl + hrs)), ...
%                   (2.*(hkl.*hr + hkl.*hrs - hr.*hrs))             ./ (hl.*hk.*(hl + hr).*(hl + hrs)), ...
%                  -(2.*(hkl.*hrs + hl.*hr + (hl-hr).*(hrs - hkl))) ./ (hkl.*hl.*hr.*hrs), ...
%                   (2.*(hkl.*hrs - hkl.*hl + hl.*hrs))             ./ (hr.*hs.*(hkl + hr).*(hl + hr)), ...
%                  -(2.*(hl.*hr + (hr - hl).*hkl))                  ./ (hrs.*hs.*(hkl + hrs).*(hl + hrs)) ];
	    N = [ -(2.*(hl.*hr + (hl - hr).*hrs)), ...
                   (2.*(hkl.*hr + hkl.*hrs - hr.*hrs)), ...
                  -(2.*(hkl.*hrs + hl.*hr + (hl-hr).*(hrs - hkl))), ...
                   (2.*(hkl.*hrs - hkl.*hl + hl.*hrs)), ...
                  -(2.*(hl.*hr + (hr - hl).*hkl)) ];
	    D =[	(hkl.*hk.*(hkl + hr).*(hkl + hrs)), ...
			(hl.*hk.*(hl + hr).*(hl + hrs)), ...
			(hkl.*hl.*hr.*hrs), ...
			(hr.*hs.*(hkl + hr).*(hl + hr)), ...
			(hrs.*hs.*(hkl + hrs).*(hl + hrs)) ];
	    A = N./D;
            % fix the first and last row by using a three point kernel
            A(1,:) = [0 2./[ (xr(1)-xl(1)).*(xc(1)-xl(1)), -(xr(1)-xc(1)).*(xc(1)-xl(1)), (xr(1)-xc(1)).*(xr(1)-xl(1)) ], 0];
            A(end,:) = [0, 2./[ (xr(end)-xl(end)).*(xc(end)-xl(end)), -(xr(end)-xc(end)).*(xc(end)-xl(end)), (xr(end)-xc(end)).*(xr(end)-xl(end)) ], 0];
            case {3} % third derivative
            N = [    6*(3*xc - xl - xr - xs), ...
                    -6*(3*xc - xk - xr - xs), ...
                     6*(4*xc - xk - xl - xr - xs), ...
                    -6*(3*xc - xk - xl - xs), ...
                     6*(3*xc - xk - xl - xr) ];
                A = N./D5;
            case {4}
            % fourth derivative
	    N = ones(size(D5,1),1)*[24 -24 24 -24 24];
	    A = N./D5;
            otherwise
                st = dbstack();
                 error(st.name,'Symmetric 5 point kernels support only derivatives up to order 4');
            end % switch derivate
            % setup the difference matrix
            L = spdiags( [    [A(3:end,1); 0; 0 ] ...
                              [A(2:end,2); 0] ...
                               A(:,3) ...
                              [0; A(1:end-1,4) ] ...
                              [0; 0; A(1:end-2,5)]    ], -2:2, n, n );
        otherwise
            st = dbstack();
            error(st.name,'Only 3 and 5 point difference kernels are implemented');
    end % switch k (kernel size)
end % fdm_d_vargrid

