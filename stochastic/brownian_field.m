% Sat 26 Nov 12:04:33 CET 2022
% Karl Kastner,
% branched from Zdravko Botev, 2016 
%
% (fractional) Brownian surfaces X(x,y) can be generated by:
% 
% Z = C^(1/2) X, where X is Gaussian iid
% with covariance C(x,y) = min(|x1|,|x2|) = |x1| + |x2| - |x1-x2|
% in 1D:
%  C =  0 0 0 0
%	0 1 1 1
%	0 1 2 2
%	0 1 2 3
%
% when X and Z are flattened into vetors
% for an nxn grid, C has n^4 elements,
% and computation of its square root is too expensive
%
% Stein's 2002 idea:
% compute a Gaussian field with covariances where the square root can be computed
% efficiently via the Fourier transform, 
% then transform the Gaussian field into a Brownian surface
%
% To understand Steins' paper one has to know how to generate Gaussian fields
% by circular embedding and the matrix algebra it is based on, which is reviewed below:
%
% 1) generate a Gaussian field with covariance
% 	K(r) = K(||x-y||)
%       K(r) = c0 - r^alpha + c2 r^2, r<1, inside the unit hypersphere
%	     = K1(r)                , 1<r<R, inside the hypersphere with radius R
%	     = 0			   , r>R, outside the second hypersphere
%   a) determine the buffer size R, only required when alpha > 3/2
%   - K is interpreted to have circular boundary conditions, i.e. K(R+delta) = K(-R+delta)
%   - the covariance matrix has (n^d)^2, d=2 rows and columns
%   - the spheres are centred at each point, i.e. the rows of the covariance matrix differ,
%     but as K is circular, each row (and column) corresponds to the preceding
%     row shifted by 1, so only 1 row has to be computed
%   b) compute C for the first quadrant x = (0,1), y = (0,1)
%   c) then pad its mirror images to extend the domain to (-1,1),
%     otherwise the (wrapped) spheres would self overlap,
%     C has therefore (2n)^(2d) elements
% 2) determine the eigenvalues of the covariance matrix S
% 	2.4 in wood and chan 1994
%	the eigenvalues of K are the fft of the (first) row or column
% 	lambda = F*C(:,1)
%       since we work in 2D, we use the 2D fft
%	lambda = F*C(:,1)*F'
%	or when C is arranged as a grid:
%	lambda = F2d*C
% 3) compute the Fourier transform of the Gaussian field
%	W = sqrtm(C)*X
%	  = (L)^(1/2)*Q'*X, Q are the eigenvectors
%         = (L)^(1/2)*tilde X, as Q'*X is just another random vector
%	- as L is diagonal, the square root is efficiently computed
%	- in two dimension L is determined via the Kronecker product,
%	  L = kron(I,lambda) = kron(lambda,I), as lambda and the identity matrix I are diagonal and therefore commute
%	however, when Z and lambda are arrange in a grid, then
%	we just have to compute it as the elementwise square toot and product
%	W = (lambda).^(1/2).*tilde X
%    - note that for taking the square root, K must be semidefinite,
%      which poses challenging constraints on K1 when alpha is large
%
% 4) compute the Gaussian field Z via the inverse Fourier transform, eq. 2.5 in Wood
%	tilde Z = 1/sqrt(m)*Q*W
%               = 1/sqrt(m)*real(F*W)
% 
% 5) transform the Gaussian field into a Brownian one by remove the term
%    c2 r = c2 |x - y|^2:
%    Z = tilde Z - sum_i=1^d x * X_i,   X_1,...X_d = N(0,2 c2)
%
% 6) clip the RxR domain into a rectangle within the first quadrant of the circle
%    i.e. sqrt(x1^2+x2^2) < 1, x1>=0, x2>=0
%
% function [FF,field2,tx,ty]=brownian_field(H,n,n3)
%% simulate Fractional Brownian field on unit disk, with Hurst parameter 'H';
%  Note that the covariance function is isotropic, see reference below.
% INPUTS:
%        - 'H' is the Hurst parameter of the Gaussian process
%        - 'n' is the number of grid points, where 'n' is a power of 2;
%            if the 'n' supplied is not a power of two,
%            then we set n=2^ceil(log2(n)); default is n=2^8;
% OUTPUT:
%          - two statistically independent fields 'field1' and 'field2'
%            over unit disk; if not output requested, then function
%            outputs a figure of one of the fields
%          - vectors 'tx' and 'ty' so that the field is plotted via
%            surf(tx,ty,field1,'EdgeColor','none')
%
% Example:
%  [field1,field2,tx,ty]=Brownian_field(.9,2^10);
%   surf(tx,ty,field2,'EdgeColor','none'),colormap bone
%% Reference:
% Kroese, D. P., & Botev, Z. I. (2015). Spatial Process Simulation.
% In Stochastic Geometry, Spatial Statistics and Random Fields(pp. 369-404)
% Springer International Publishing, DOI: 10.1007/978-3-319-10064-7_12
%
function [FF,field2,tx,ty]=brownian_field(H,n,n3)
if (H>1)|(H<0) % Hurst parameter error check
    error('Hurst parameter must be between 0 and 1');
end
% only the first quadrant of the circular section is kept
% so we need to set n = sqrt(2)*2*n = sqrt(8)*n
n0 = n;
n = 2^(1/2)*2*n;
%n = 2^(1/4)*2*n;
if nargin<2
    n=2^8; % default value of points
else
    n=2^ceil(log2(n));
end

if (nargin()<3)
	n3 = 1;
end
alpha = 2*H;

% note that R can be 1 when alpha = 2 H < 1.5
if (alpha<=1.5)
	R = 1;
else
	% TODO R should be kept as close to 1 as possible (c.f. Stein)
	% and it is possible to choose 1<R<2 depending on alpha
	R=2; % [0,R]^2 grid, may have to extract only [0,R/2]^2
end
R=2;
m=n; % size of grid is m*n; covariance matrix is m^2*n^2
% note, the original code has 1:n
tx=[0:n-1]/n*R;
ty=[0:m-1]/m*R; % create grid for field
[X,Y]=meshgrid(tx,ty);
if (0)
Rows=zeros(m,n);
for i=1:n
    for j=1:m % rows of blocks of cov matrix
        Rows(j,i)=covariance(tx(i),ty(j),tx(1),ty(1),R,alpha);
    end
end
else
tx_ = repmat(cvec(tx),1,length(ty));
ty_ = repmat(rvec(ty),length(tx),1);
[Rows_,~,c2] = covariance(tx_(:),ty_(:),tx(1),ty(1),R,alpha);
Rows = reshape(Rows_,m,n);
end
%rms(flat(Rows-Rows_))
% there seems to be a mistake here, a 0 inserted to make the matrix size 2nx2n?
BlkCirc_row=[Rows, Rows(:,end-1:-1:2);
             Rows(end-1:-1:2,:), Rows(end-1:-1:2,end-1:-1:2)];
% compute eigen-values
lam=real(fft2(BlkCirc_row))/(4*(m-1)*(n-1));
lam=sqrt(lam);
%[~,~,c2]=covariance(0,0,0,0,R,alpha);
FF = zeros(m/2,n/2,n3);
for idx=1:n3
	% generate field with covariance given by block circular matrix
	Z=complex(randn(2*(m-1),2*(n-1)),randn(2*(m-1),2*(n-1)));
	F=fft2(lam.*Z);
	F=F(1:m,1:n); % extract sub-block with desired covariance
	field1=real(F);
	% set field zero at origin
	field1=field1-field1(1,1);
	% make correction for embedding with a term c2*r^2
	% note, the original code had the outer product tx*ty, which is not what stein does
	field1 = field1 + (sqrt(2*c2)*randn())*ty' + (sqrt(2*c2)*randn())*tx;
	%field1=field1 + kron(ty'*randn(),tx*randn())*sqrt(2*c2);
	field1((X.^2+Y.^2)>1)=nan;
	field1=field1(1:n/2,1:m/2);
	
	if (0)
	field2=imag(F); % two independent fields
	field2=field2-field2(1,1); % set field zero at origin
	field2=field2 + kron(ty'*randn(),tx*randn())*sqrt(2*c2);
	field2((X.^2+Y.^2)>1)=nan;
	field2=field2(1:n/2,1:m/2);
	end
	FF(:,:,idx) = field1;
end
FF = FF(1:n0,1:n0,:);
tx=tx(1:n/2);
ty=ty(1:m/2);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% covariance K in Stein 2002 and Schmidt 2015
% alpha=2*H, where H is the Hurst parameter
function [out,c0,c2] = covariance(x1,x2,y1,y2,R,alpha)
	% embedding of covariance function on a [0,R]^2 grid
	if alpha<=1.5
	    beta=0;
	    c0=1-0.5*alpha;
	    c2=0.5*alpha;
	else % parameters ensure piecewise function twice differentiable
	    beta=alpha*(2-alpha)/(3*R*(R^2-1));
	    c2=(alpha-beta*(R-1)^2*(R+2))/2;
	    c0=beta*(R-1)^3+1-c2;
	end
	% for r>R out is 0
	out = zeros(size(x1));
	% create continuous isotropic function
	r = hypot(x1-y1,x2-y2);
	fdx = r<=1;
	% eq. 2.1 in Stein 2002
	% eq. 12.18 in Schmidt, 2015
	out(fdx)=c0-r(fdx).^alpha+c2*r(fdx).*r(fdx);
	if (R>1)
		fdx = r>1 & r<=R;
		% first order bessel function?
		out(fdx) = beta*(R-r(fdx)).^3./r(fdx);
	end
	%fdx = r>R;
	%out(fdx) = 0;
	%if r<=1
	%elseif r<=R
	%    out=beta*(R-r).^3./r;
	%else
	%    out=0;
	%end
end
